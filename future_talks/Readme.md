##future talks

<b>Programming Paradigms</b><br>
(1) talk on programming paradigms, part two of what every programmer needs to know.
<br>(2) why one should learn many languages in that particular paradigm.
<br>(3) Knowing paradigms you become powerful... you can shift languages into other languages and build what you actually need. You can think about code differently.
<br>(4) A big problem occours in scaling compiled software. Bang your head for hours, weeks years. Being stubborn you may not find an answer. Even if a solution does exist, you are human and may miss; and if you find a solution it may not be optimal, readable, or maintainable. Knowing programming paradigms; thinking about the nature of what you are trying to do, and what the programming paradigm characteritics the task requires; enables the programmer to come from a mindset that will be more likely to produce answers and the thourough nature of thinking all paradigms availiable will more likely lead to the optimal solution.

<br><b>Programming at Runtime/ Metaprogramming </b><br>
<br><b>start out Refactoring, defer to common sense.</b><br>
(1) warstory example: bad recursion. How refactoring helped turned bad recursion into better recursion.
<br>(2) bad recursion: (long) (complex) (unreadable) (uncontrolled) but worked.
<br>(3) (shorten, slowly chip away at the wall) turn each action into a readable method to be called in that location instead. -note, more aware of what variables are used and can remove some complexity.
<br>(4) (shorten the base of the wall) seperate large chunks of the program, possibly only removing one line, make the chunks your new largest method.
<br>
<br>
